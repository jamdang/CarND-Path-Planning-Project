# CarND-Path-Planning-Project Writeup
======

Self-Driving Car Engineer Nanodegree Program

## Intro
------
This writeup provides a brief description of how the project is done. Basically, the solution follows the traditional robotics approach taught in Udacity's program and consists of three key parts (pipeline):
- Traffic prediction
- Maneuver planning
- Trajectory planning

## Source Files Brief
------
#### `helper.h` `helper.cpp` `spline.h`
Common auxiliary functions are placed here. Some functions in the original `main.cpp` file such as `NextWaypoint()` are also moved here to make code in the `main()` cleaner.
`spline.h` is a header file containing open source code for spline fitting, downloaded [here](http://kluge.in-chemnitz.de/opensource/spline/).
 #### `traffic_prediction.h` `traffic_prediction.cpp`
Here defined and implemented are two classes: `TrafficParticipant` (individual surrounding car) and `Traffic` (collection of surrounding cars, organized using standard C++ data structure map). Traffic prediction is done here (`GetFrenetStateInTime()`).   
#### `ego_car.h` `ego_car.cpp`
Defined and implemented here are mainly the `EgoCar` class. All maneuver planning and trajectory planning related functions, including corresponding cost functions, are implemented as member functions of this class.
#### `main.cpp`
The main code is added in the TODO section.

Please note that `CMakeLists.txt` is changed due to the way the code is organized as described above.

## Pipeline Brief  
------
#### 1. Traffic Prediction
Traffic prediction is supposed to consists of two parts: Maneuver detection (`TrafficParticipant::DetectManeuver()`) + Trajectory prediction (`TrafficParticipant::GetFrenetStateInTime`), both realized as member functions of class `TrafficParticipant`. For simplicity and in light of the characteristics of the simulator, the maneuver detection is basically omitted (API is kept for potential future implementation) with all traffic participant "detected" as keeping its current lane.

#### 2. Maneuver Planning
The whole path planning is realized with `EgoCar::PlanPath()`, which in turn consists of `EgoCar::PlanManeuver()` (maneuver planning) and `EgoCar::GenerateTrajectory()` (trajectory planning).

For *maneuver planning*, three maneuvers were considered, namely, Lane Keeping (LK), Lane Change to the Left (LCL), and Lane Change to the Right (LCR), which means there is no preparation stage for lane changes, the ego car will only change lanes when certain conditions are meet (corresponding cost function is the lowest).

The main steps of maneuver planning include:
- Get the next possible maneuver/state `EgoCar::GetSuccessorStates()`
- For each possible maneuver/state, generate a possible trajectory in Frenet coordinate `EgoCar::GetFrenetTraj()`
- For each possible maneuver/state, calculate the corresponding cost `EgoCar::CalcManeuverCost()`, which is basically a weighted sum of a bunch of cost functions.

#### 3. Trajectory Planning
For *trajectory planning*, the main steps include:
- Generate a bunch of possible goals with `EgoCar::GeneratePossibleGoals()`, with each goal consisting of a target s, a target d, and target speed in s direction `{target_s, target_d, target_vs}`. ...
The variation is mainly in the target_vs dimension: for the planned maneuver, there will be a default `target_vs` (generated by maneuver planner) that's typically the min of the speed limit and the leading vehicle speed of target lane. When trajectory planner receives this `target_vs`, it then generate a bunch of goals around this default `target_vs`.
- Generate a bunch of possible trajectories according to the target goals from the last step, with `EgoCar::GeneratePossibleTrajectories()`. Basically, the trajectories are generated using the spline method taught in the project walkthrough video. `target_s` and `target_d` are used to generate a spline, then points are picked from this spline by gradually increasing the distance while limiting the speed of ego car.
- Find the best trajectory using `EgoCar::FindBestTrajectory()` with the lowest cost function calculated by `EgoCar::CalcTrajCost()`.
